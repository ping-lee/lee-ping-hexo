---
title: 负载均衡
date: 2021-02-23 18:41:59
tags: [计算机, 数据库]
---

<div class="toc" style="list-style: decimal-leading-zero;">
<!-- toc -->
</div>

##### 负载均衡
###### 快速介绍负载均衡和负载均衡器


负载平衡在于聚合多个组件，以使总处理能力超过每个组件的单个能力，而无需最终用户的任何干预，并且采用可扩展的方式。 这样导致更多的操作在同一时间被同步执行，当然一个组件只执行一个操作。同一时间单个操作仍然在单个组件上执行，并且不会比没有负载平衡时更快。 它总是获取尽量多的操作以使可用组件和负载均衡机制来充分使用全部组件并且从 负载均衡中充分受益。 高速公路上的车道数量就是一个很好的例子，它可以在不增加车速的情况下在同一时间段内通过尽可能多的汽车。

负载均衡示例：

- 多处理器系统中的流程调度
- 链路负载平衡（例如EtherChannel，Bonding）
- IP地址负载平衡（例如ECMP，DNS轮询）
- 服务器负载平衡（通过负载平衡器）

执行负载平衡操作的机制或组件称为负载平衡器。 在Web环境中，这些组件被称为“网络负载平衡器”，并且更常见的是“负载平衡器”，因为此活动是迄今为止最著名的负载平衡情况。

负载均衡器可以执行以下操作：
- 在链路级别：这称为链路负载平衡，它包括选择要将数据包发送到的网络链路；
- 在网络级别：这称为网络负载平衡，它包括选择一系列数据包将遵循的路由；
- 在服务器级别：这称为服务器负载平衡，它在于确定将由哪个服务器处理连接或请求。

###### 什么是HAProxy，什么不是
HAProxy是：
- TCP代理：它可以接受来自侦听套接字的TCP连接，连接到服务器并将这些套接字连接在一起，从而使流量可以双向流动； 双方都支持IPv4，IPv6甚至UNIX套接字，因此这可以提供一种在不同系列之间转换地址的简便方法。
- HTTP反向代理（在HTTP术语中称为“网关”）：它本身表示为服务器，通过侦听TCP套接字上接受的连接接收HTTP请求，然后使用不同的连接将这些请求从这些连接传递到服务器。 它可以在任何一侧使用HTTP / 1.x或HTTP / 2的任意组合，甚至可以在TLS上使用ALPN时自动检测每侧所说的协议。
- SSL终结器/启动器/卸载程序：SSL / TLS可以用于来自客户端的连接，去往服务器的连接，甚至可以用于两个连接。 每个名称（SNI）可以应用很多设置，并且可以在运行时进行更新而无需重新启动。 这种设置具有极高的可扩展性，据报道涉及数以万计的证书的部署。
- TCP规范化器：由于连接由操作系统在本地终止，因此双方之间没有关系，因此异常流量（例如无效数据包，标志组合，窗口广告，序列号，不完整的连接（SYN泛洪）等）不能传递到另一边。 这样可以保护脆弱的TCP堆栈免受协议攻击，并且可以在不修改服务器的TCP堆栈设置的情况下优化与客户端的连接参数。
- HTTP规范化器：配置为处理HTTP流量时，仅传递有效的完整请求。 这样可以防止许多基于协议的攻击。 此外，规范中存在公差的协议偏差是固定的，这样它们就不会在服务器上引起问题（例如，多行标头）。
- HTTP修复工具：它可以修改/修复/添加/删除/重写URL或任何请求或响应标头。 这有助于解决复杂环境中的互操作性问题。
- 基于内容的交换机：它可以考虑请求中的任何元素，以决定将请求或连接传递给哪个服务器。 因此，可以在同一端口上处理多种协议（例如HTTP，HTTPS，SSH）。
- 服务器负载平衡器：它可以负载平衡TCP连接和HTTP请求。 在TCP模式下，将对整个连接进行负载平衡决策。 在HTTP模式下，每个请求都会做出决定。
- 流量调节器：它可以在各个点上应用一些速率限制，保护服务器免受过载，根据内容调整流量优先级，甚至通过标记数据包将此类信息传递给较低层和外部网络组件。
- 防止DDoS和服务滥用：它可以维护每个IP地址，URL，Cookie等的大量统计信息，并检测何时发生滥用，然后采取行动（放慢违规者的速度，阻止他们，将他们发送到过时的地方内容等）。
- 网络故障排除的观察点：由于日志中报告的信息精确，因此通常用于缩小某些与网络相关的问题。
- HTTP压缩卸载程序：它可以压缩服务器未压缩的响应，从而为连接性差或使用高延迟移动网络的客户端减少了页面加载时间。
- 缓存代理：它可以将响应缓存在RAM中，以便对同一对象的后续请求避免了从服务器进行另一次网络传输的开销，只要该对象仍然存在且有效。 但是，它不会将对象存储到任何持久性存储中。 请注意，此缓存功能旨在免维护，仅专注于节省haproxy的宝贵资源，而不是节省服务器的资源。 设计用于优化服务器的缓存需要更多的调整和灵活性。 如果您需要这样的高级缓存，请使用Varnish缓存，该缓存可与haproxy完美集成，尤其是在任何一侧都需要SSL / TLS时。
- FastCGI网关：FastCGI可以看作是HTTP的不同表示形式，因此，HAProxy可以直接负载均衡包括FastCGI应用程序服务器的任何组合的服务器场，而无需在它们之间插入另一级网关。 这样可以节省资源并减少维护成本。

HAProxy不是：
- 一个显试的HTTP代理，即 浏览器用来访问互联网的代理。 有专门用于此任务的出色开源软件，例如Squid。 但是，可以将HAProxy安装在此类代理的前面，以提供负载平衡和高可用性。
- 数据清理器：它不会修改请求或响应的主体。
- 静态Web服务器：在启动过程中，它会将自己隔离在chroot监狱中并丢弃其特权，因此启动后将不会执行任何单个文件系统访问。 因此，它不能转换为静态Web服务器（但是FastCGI支持动态服务器）。 有许多出色的开源软件，例如Apache或Nginx，并且HAProxy可以轻松地安装在它们前面，以提供负载平衡，高可用性和加速。
- 基于数据包的负载均衡器：它将不会看到IP数据包或UDP数据报，不会执行NAT甚至更少的DSR。 这些是较低层的任务。 一些基于内核的组件（例如IPVS（Linux虚拟服务器））已经很好地完成了此任务，并与HAProxy完美互补。

###### HAProxy原理

HAProxy是一个事件驱动的非阻塞组合引擎，具有非常快的I / O层和基于优先级的多线程调度程序。 由于设计时考虑了数据转发目标，因此对其架构进行了优化，以尽可能少的操作尽可能快地移动数据。 它着重于通过尽可能长时间地保持与同一CPU的连接来优化CPUcache的效率，因此它实现了一个分层模型，该模型在每个级别都提供了旁路机制，确保除非需要，否则数据不会达到更高的级别。 大多数处理都是在内核中执行的，并且HAProxy会尽力帮助内核通过给出一些提示或避免某些可能会在以后进行分组的操作避免某些操作，从而尽可能快地完成工作。 结果，典型数据显示，在HAProxy中花费15％的处理时间，而在TCP或HTTP关闭模式下，在内核中花费的处理时间为85％，对于在HTTPkeep-alive模式下的HAProxy，内核花费了70％的时间，而对于内核则为70％。

一个进程可以运行许多代理实例。 据报道，在单个过程中配置多达300000个不同代理的配置运行良好。 单核，单CPU设置对于99％以上的用户来说已经绰绰有余了，因此，鼓励容器和虚拟机的用户使用它们所能获得的绝对最小的映像，以节省运营成本并简化故障排除。 但是，运行HAProxy的计算机绝不能交换，并且其CPU不能被人为节制（虚拟机管理程序中的子CPU分配），也不能与计算密集型进程共享，这会导致很高的上下文切换延迟。

线程允许通过每个CPU内核使用一个线程来利用所有可用的处理能力。 这对于SSL或需要40 Gbps以上的数据转发速率时非常有用。 在这种情况下，至关重要的是避免多个物理CPU之间的通信，这可能会导致网络堆栈和HAProxy本身出现严重的瓶颈。 尽管有些违反直觉，但是面对某些性能问题时，第一件事通常是减少HAProxy运行的CPU数量。

HAProxy仅需要运行haproxy可执行文件和一个配置文件即可，强烈建议您使用正确配置的syslog守护程序和日志轮换进行日志记录。 日志也可以发送到stdout / stderr，这在容器内部可能很有用。 在启动之前，将对配置文件进行解析，然后HAProxy尝试绑定所有侦听套接字，并在任何失败的情况下拒绝启动。 超过这一点，它再也不会失败。 这意味着没有运行时失败，并且如果它接受启动，它将一直运行直到停止。

一旦启动HAProxy，它将执行3件事：
- 处理传入的连接；
- 定期检查服务器的状态（称为运行状况检查）；
- 与其他haproxy节点交换信息。

到目前为止，处理传入连接是最复杂的任务，因为它取决于许多配置可能性，但可以将其概括为以下9个步骤：
- 接受来自侦听套接字的传入连接，这些侦听套接字属于一个称为“前端”的配置实体，该配置实体引用一个或多个侦听地址；
- 对这些连接应用特定于前端的处理规则，这些规则可能导致阻塞，修改某些标头或拦截它们以执行某些内部小程序，例如统计信息页面或CLI；
- 将这些传入连接传递到另一个表示服务器场的配置实体，称为“后端”，其中包含服务器列表和该服务器场的负载平衡策略；
- 将特定于后端的处理规则应用于这些连接；
- 根据负载平衡策略决定将连接转发到哪个服务器；
- 将特定于后端的处理规则应用于响应数据；
- 将特定于前端的处理规则应用于响应数据；
- 发出日志以详细报告发生的情况；
- 在HTTP中，循环回到第二步以等待新请求，否则关闭连接。

前端和后端有时被视为半代理，因为它们仅查看端到端连接的一侧；前端只关心客户端，而后端只关心服务器。HAProxy还支持完全代理，它们完全是前端和后端的结合。当需要进行HTTP处理时，通常将配置分为前端和后端，因为它们打开了很多可能性，因为任何前端都可以将连接传递给任何后端。对于仅使用TCP的代理，使用前端和后端可以带来好处，并且完整代理可以使配置更具可读性。


##### 关于HTTP的快速回忆

当HAProxy在HTTP模式下运行时，对请求和响应都进行了充分的分析和索引，因此可以对内容中建立匹配标准。

但是，了解HTTP请求和响应的封装方式以及HAProxy如何分解它们很重要。这样，编写正确的规则和调试现有配置将变得更加容易。

###### HTTP会话模型

HTTP协议是事务驱动的。 这意味着每个请求将只导致一个响应。 传统上，从客户端到服务器建立TCP连接，客户端通过连接发送请求，服务器响应，然后关闭连接。 一个新的请求将涉及一个新的连接：

 [连接1] [请求1] ... [回复1] [关闭1] [连接2] [请求2] ... [回复2] [关闭2] ...

 在这种模式下，称为“ HTTP关闭”模式，连接建立与HTTP事务一样多。 由于服务器在响应后关闭了连接，因此客户端不需要知道内容长度。

 由于该协议的事务性质，有可能对其进行改进，以避免关闭两个后续事务之间的连接。但是，在这种模式下，服务器必须指示每个响应的内容长度，以便客户端不会无限期地等待。 为此，使用了特殊的头：“ Content-length”。 此模式称为“保持活动”模式：

 [连接] [请求1] ... [回复1] [请求2] ... [回复2] [关闭] ...

它的优点是减少了事务之间的等待时间，并减少了服务器端所需的处理能力。它通常比关闭模式更好，但并非总是如此，因为客户端经常将其并发连接限制为较小的值。

通信的另一项改进是流水线模式。它仍然使用保持活动状态，但是客户端不等待第一个响应发送第二个请求。这对于获取大量组成页面的图像很有用：

[连接] [请求1] [请求2] ... [回复1] [回复2] [关闭] ...

显然，这可以极大地提高性能，因为可以消除后续请求之间的网络延迟。由于无法将响应与HTTP中的相应请求相关联，因此许多HTTP代理不正确支持流水线。 因此，服务器必须按照与收到请求完全相同的顺序进行回复。

下一个改进是在HTTP/2中实现的多路复用模式。这次，为每个事务分配一个单一的流标识符，并且所有流在现有连接上进行多路复用。客户端可以并行发送许多请求，并且由于响应还带有流标识符，因此响应可以以任何顺序到达。

默认情况下，HAProxy针对持久连接在保持活动状态下运行：对于每个连接，HAProxy都会处理每个请求和响应，并在响应结束和新请求开始之间在两端保持连接空闲。当它从客户端接收到HTTP/2连接时，它将并行处理所有请求，并使连接处于空闲状态，等待新请求，就像它是一个保持活动状态的HTTP连接一样。

HAProxy支持4种连接模式：

- 保持活动：所有请求和响应均已处理（默认）。
- 隧道：仅处理第一个请求和响应，其他所有内容都转发而没有分析（不建议使用）。
- 服务器关闭：响应后关闭面向服务器的连接。
- 关闭：响应结束后主动关闭连接。

###### HTTP请求

首先，让我们考虑一下这个HTTP请求：
```bash
Line     Contents
number
  1     GET /serv/login.php?lang=en&profile=2 HTTP/1.1
  2     Host: www.mydomain.com
  3     User-agent: my small browser
  4     Accept: image/jpeg, image/gif
  5     Accept: image/png
```

###### 请求行

第1行是“请求行”。 它始终由3个字段组成：

- 方法：Get
- URI：/serv/login.php?lang=zh-TW&profile=2
- 版本标记：HTTP / 1.1

所有这些都由标准称为LWS（线性空格）界定，LWS是常见的空格，但也可以是制表符或换行符/回车符，后跟空格/制表符。该方法本身不能包含任何冒号（'：'），并且仅限于字母。所有这些各种组合使得HAProxy希望自己执行拆分，而不是让用户编写复杂或不正确的正则表达式。

URI本身可以有几种形式：
- “相对URI”：`/serv/login.php?lang=en&profile=2`，它是一个完整的URL，不包含主机部分。通常，这是服务器，反向代理和透明代理所接收的。
- 一个“绝对URI”，也称为“ URL”：`http://192.168.0.12:8080/serv/login.php?lang=en&profile=2`，它由“方案”（协议名称后跟“：//”），主机名或地址，可选的冒号（“：”），端口号以及从第一个斜杠开始的相对URI组成。（'/'）在地址部分之后。通常这是代理收到的，但是支持HTTP/1.1的服务器也必须接受此格式。
- 星号（'*'）：仅与OPTIONS方法结合使用此格式，并且不可中继。用于查询下一跳的功能。
- 地址：端口组合：192.168.0.12:80与CONNECT方法一起使用，该方法用于通过HTTP代理建立TCP隧道，通常用于HTTPS，但有时也用于其他协议。

在相对URI中，标识了两个子部分。 问号之前的部分称为“路径”。 它通常是服务器上静态对象的相对路径。 问号之后的部分称为“查询字符串”。 它通常与发送到动态脚本的GET请求一起使用，并且非常特定于所使用的语言，框架或应用程序。

HTTP/2不随请求传递版本信息，因此假定该版本与基础协议之一（即“ HTTP/2”）相同。

###### 请求标头

标头从第二行开始。 它们由该行的业务名称组成，后跟冒号（'：'）。 传统上，LWS是在冒号之后添加的，但这不是必需的。 然后是这些值。可以将多个相同的标头折叠成一行，并使用逗号分隔值，前提是要遵守它们的顺序。 这通常在“ Cookie：”字段中遇到。 如果后续行以LWS开头，则标头可能会跨越多行。 在1.2的示例中，第4行和第5行为``Accept：''标头总共定义了3个值。

与常见的误解相反，标头名称不区分大小写，如果它们引用其他标头名称（例如``Connection：''标头），它们的值也不区分大小写。 在HTTP/2中，标头名称始终以小写形式发送，如在调试模式下运行时所见。 在内部，所有标头名称均被标准化为小写，以便HTTP/1.x和HTTP / 2使用完全相同的表示形式，并在另一侧按原样发送。 这解释了为什么使用驼峰式大小写的HTTP/1.x请求以小写形式传递。

标头的末尾由第一个空行指示。 人们经常说这是双换行，即使双换行是空行的一种有效形式，也不是完全正确。

幸运的是，HAProxy在为标头建立索引，检查值并对其进行计数时会处理所有这些复杂的组合，因此没有理由担心它们的编写方式，但重要的是不要指责应用程序存在错误它做不寻常的，有效的事情。

重要的提示：
    
如RFC7231所建议，HAProxy通过用LWS替换标题中间的换行符来标准化标题，以便加入多行标题。 这对于正确的分析是必要的，它可以帮助功能较弱的HTTP解析器正常工作，而不被此类复杂的构造所迷惑。

##### HTTP响应

<div style="overflow: auto;">
{% barchart 'Barchart with Horizontal Headings' %}
Durian | Clementine | Durian | Mulberry | Papaya | Rambutan
97 | 72 | 89 | 93 | 68 | 75
{% endbarchart %}

{% linechart 'Linechart with Horizontal Headings' %}
Durian | Clementine | Durian | Mulberry | Papaya | Rambutan
97 | 72 | 89 | 93 | 68 | 75
{% endlinechart %}
</div>

{% spoiler title %}
content
{% endspoiler %}